import { defineCollection, defineConfig } from '@content-collections/core';
import { z } from 'zod';

// const linkTitleSchema = z.object({
//   "link": z.string(),
//   "title": z.string(),
// });

// Custom-Implemented for Handling Sphinx Documentation
const apiDocsSchema = z.object({

    title: z.string(),
    description: z.string().optional(),
    // content: z.string(),
    toc: z.string().optional(),
    htmltoc: z.string().optional(),
    structuredData: z.string().optional(),
    
    body: z.string(),

    // meta: z.string(),
    // Icon? _openapi?
    // full: z.ZodOptional<z.ZodBoolean>;
    // _openapi: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
})

// // Also "passthrough" any other unaddressed and remaining properties.
// }).passthrough();

// type meta = {
//   filePath: string,
//   fileName: string,
//   directory: string,
//   extension: string,
//   path: string,
// }

const apiDocs = defineCollection({
  name: 'apiDocs',
  directory: 'content/docs',
  include: '**/*.fjson',
  parser: 'json',
  schema: apiDocsSchema,
  onSuccess: (docs) => {
    console.log(`Generated a collection of API documents containing ${docs.length} item${(docs.length == 1) ? "" : "s"}!`);
    // console.log(docs[0]);
  },
  transform: async (doc, { cache }) => {

    const title = await cache(
        doc.title || "",
        async (title: string) => {
          // Remove title formatting.
          title = title.replace(/^<code.*"pre">/, "");
          title = title.replace("</span></code>", "")

          return title
        }
      );

    // Legacy TOC Parsing
    // let toc = await cache(
    //   doc.toc || "",
    //   async (toc: string) => {

    //     // Pull out data and function names.
    //     let structuredTOC = [];

    //     let matchRE = /<li><a class="reference internal" href="(.*?)"><code class="docutils literal notranslate"><span class="pre">(.*?)<\/span><\/code><\/a><\/li>/g;

    //     let currentMatch = matchRE.exec(toc);
    //     while (currentMatch != undefined){
    //       const currentLink = currentMatch[1];
    //       const currentTitle = currentMatch[2];

    //       structuredTOC.push({
    //         "title": currentTitle,
    //         "url": currentLink,
    //         "depth": 3,
    //       });

    //       currentMatch = matchRE.exec(toc);
    //     }

    //     return structuredTOC
    //   }
    // );

    // Remove the repeated header title.
    // - The "s" flag after the closing backward slash allows the dot (.) wildcard to match all characters
    // - (including newlines).
    const htmltoc = doc.toc?.replace(/^<ul>.*module<\/a>/s, "").replace(/<\/ul>.*$/s, "");

    // Process/Format the body and extract structured representations for the search indices and table of contents.
    const [body, structuredData, toc] = await cache(
      doc.body,
      async (body: string) => {

        // Specify the structure of:
        // - structuredData: Used by the search provider to construct search indices for offline searching.
        let structuredData : {contents: {heading: string, content:string}[], headings:{id: string, content: string}[]} = {
          contents: [],
          headings: [],
        };
        // - toc: Used by Fumadocs to generate a sidebar table of contents containing document headers.
        type tocType = {title: string, url:string, depth:number, offset:number}[];
        let toc : tocType[] = [];

        // Pre-Process the body by removing extraneous code exported by Sphinx.
        // Remove the following:
        // - The leading body contents before the API Section
        // - The duplicate header provided by Sphinx (which will be be regenerated by Fumadocs)
        body = body.replace(/^.*?API.*?h3>\n/s, "").replace(/<h1>.*?<\/h1>/, "");

        // Rewrite Links to local paths.
        body = body.replace(/href="../g, "href=\"./");

        // 
        // Table of Contents Processing
        //

        

        // Parse the Sphinx Table of Contents to extract appropriate names to display.
        let matchRE = /<a class="reference internal" href="(.*?)"><code class="docutils literal notranslate"><span class="pre">(.*?)<\/span>/g;
        // We're not truly replacing any matches; we're just using `replace` to cleanly apply a function over all of the matches.
        doc.toc?.replace(matchRE, (match, currentLink, currentTitle) => {

          // Locate the current item inside the body to get a sense of its position relative to headers and other items.
          const currentLocation = body.indexOf(currentLink.substring(1));

          // Push all of this information into the structured toc list.
          toc.push({
            title: currentTitle,
            url: currentLink,
            depth: 4,
            offset: currentLocation,
          });

          return "";
        
        })

        // 
        // Body Processing
        // 

        

        // Extract Breathe Headings Previously Exported to HTML
        function extractHeadings(text: string, tocDepth: number, startingOffset: number){

          let workingToc : tocType[] = [];

          const titleRE = /<p (class=.*?breathe-sectiondef.*?)id="(.*?)".*?>(.*?)<\/p>/g;
          const updatedText : string = text.replaceAll(titleRE, (match, other_attributes, id, title, offset) => {

            const fullOffset = offset + startingOffset;

            // Append the current offset to ensure each toc entry links to a unique header.
            const newID = `${id}-${fullOffset}`

            workingToc.push({
              title: title,
              url: `#${newID}`,
              depth: tocDepth,
              offset: fullOffset
            });

            // Set the header level based on the toc depth.
            let headerTag = "h3"
            if (tocDepth == 3){
              headerTag = "h4"
            }

            // Insert a horizontal line for all primary-header-levl matches under the first match.
            const template = `<${headerTag} ${other_attributes} id="${newID}">${title}</${headerTag}>`;
            if(tocDepth == 2 && workingToc.length != 1){
              return "<hr>" + template;
            }
            else{
              return template;
            }
          });

          return [workingToc, updatedText];
        }


        // Identify, Highlight/Format, and Record Breathe Sections.
        let extractedSubHeadingtocEntries : tocType[] = []
        body = body.replace(/<dd><div.*?<\/div>\n<\/dd>/gs, (match, offset) => {

          // Return early if the current item is empty.
          if (match == "<dd></dd>"){
            return match;
          }

          const [newtocEntries, updatedContent] = extractHeadings(match, 3, offset);
          
          extractedSubHeadingtocEntries.push(...newtocEntries);

          return updatedContent;
        });

        const [primaryHeadings, updatedBody] = extractHeadings(body, 2, 0);
        body = updatedBody;

        toc = [
          ...toc,
          ...primaryHeadings,
          ...extractedSubHeadingtocEntries,
        ];
        
        
        // Create a structured representation of each listed item for search.
        const sectionParseRE = /<dl.*?id="(.*?)".*?<dd>(.*?)<\/dd>/sg;

        let currentMatch = sectionParseRE.exec(body);
        while (currentMatch != undefined){

          const currentHeading = currentMatch[1];
          const currentContent = currentMatch[2].replace(/<.*?>/g, "").replace("\n", " ");

          structuredData.contents.push({
            "heading": currentHeading,
            "content": currentContent,
          });

          structuredData.headings.push({
            "id": currentHeading,
            "content": currentHeading
          });

          currentMatch = sectionParseRE.exec(body);
        }

        toc.sort((a, b) => {
          return a.offset - b.offset;
        })

        return [body, structuredData, toc];
      }
    );

    const newObject = {
      ...doc,
      title,
      toc,
      body,
      
      // title: document.title,
      // // description: ,
      htmltoc,
      // body: body,
      _meta: doc._meta,
      structuredData,

      // _meta: document._meta,

      // ...document,
      // title: document.title,
      // // description: ,
      // // toc: ,
      // htmltoc: toc,
      // body: body,

      // _meta: document._meta,

      // // ...document,
      // // body,
      // // toc
    };

    return newObject;

  },
})

export { apiDocs }